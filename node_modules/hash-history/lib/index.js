'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propertiesAndEvents = require('properties-and-events');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var History = function () {
  function History(id, codec) {
    var _this = this;

    _classCallCheck(this, History);

    this.id = id;
    this.codec = codec;
    (0, _propertiesAndEvents.addEvents)(this, 'change');
    this._current = null;
    this._suppressEvents = false;
    var later = function later() {
      var hashchangeHandler = function hashchangeHandler(e) {
        if (!_this._suppressEvents) {
          var newValue = _this._getRaw();
          if (newValue != _this._current) {
            _this._current = newValue;
            _this.fire('change', _this.get());
          }
        }
      };
      _this._current = _this._getRaw();
      window.addEventListener('popstate', hashchangeHandler, false);
    };
    setTimeout(later, 1);
  }

  _createClass(History, [{
    key: 'get',
    value: function get() {
      var value = this._getRaw();

      // the default codec just replaces spaces with + signs
      if (value && typeof value === 'string') {
        value = value.replace(/\+/g, ' ');
      }

      if (this.codec) {
        value = this.codec.parse(value);
      }
      return value;
    }

    /*
    set the given value on this history token. If a codec is present, then
    the value will be stringified with the codec first. The description is
    used to temporarily set the title of the browser while changing the
    url, so this title will show up in history
    */

  }, {
    key: 'set',
    value: function set(value, description) {
      var id = this.id;
      //this._current = value
      if (this.codec) {
        value = this.codec.stringify(value);
      }

      // could use escape() here, but + for space is prettier, shorter
      // and more human readable than %20
      if (value) {
        value = value.replace(/\s/g, '+');
      }

      this._suppressEvents = true;
      var hash = unescape(window.location.hash);
      var re = new RegExp('([#|&])' + id + '=.*?(&|$)', 'i');
      var separator = hash.indexOf('#') != -1 ? '&' : '#';
      var valueInHash = value ? id + '=' + value : '';
      if (hash.match(re)) {
        hash = hash.replace(re, '$1' + valueInHash + '$2');
      } else {
        hash += separator + valueInHash;
      }
      hash = hash.replace(/\&\&/g, '&');
      hash = hash.replace(/\&$/, '');
      var currentTitle = window.document.title;
      if (description) {
        window.document.title = currentTitle + ' - ' + description;
      }
      window.location.hash = hash;
      if (description) {
        window.document.title = currentTitle;
      }
      this._current = this._getRaw();
      this._suppressEvents = false;
    }

    // based on http://stackoverflow.com/questions/5999118/add-or-update-query-string-parameter

  }, {
    key: '_getRaw',
    value: function _getRaw() {
      var hash = unescape(window.location.hash).replace('/\+/g', ' ');
      var re = new RegExp('[#|&]' + this.id + '=(.*?)(&|$)', 'i');
      var separator = hash.indexOf('#') != -1 ? '&' : '#';
      var match = hash.match(re);
      return match ? match[1] : null;
    }
  }]);

  return History;
}();

exports.default = History;